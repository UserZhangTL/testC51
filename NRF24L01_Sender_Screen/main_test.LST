C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:18:58 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN_TEST
OBJECT MODULE PLACED IN main_test.OBJ
COMPILER INVOKED BY: C:\Keil_MDK\C51\BIN\C51.EXE main_test.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\delay;.\uart;.\NRF24L01__
                    -Sender;.\nine_key;.\HandSignal) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          名称：无线广告屏发送端
   3          作者：张天乐
   4          更新时间：2016/5/21
   5          更新内容：删除无用模块内容，留下有用的NRF发送部分
   6          
   7          
   8          */
   9          
  10          
  11          #include "AllFunc.h"
  12          
  13          extern unsigned char Direction_flag;
  14          extern bit One_s_Come;
  15          
  16          
  17          unsigned char Hand_Switch = NO;//打开手势标志位，默认是关闭的
  18          
  19          void Iner0_Init()//按键11，控制手势的关
  20          {
  21   1          EA = 1; //总中断
  22   1          EX0 = 1;//允许外部中断0
  23   1          IT0 = 0;//设置为低电平触发
  24   1      }
  25          
  26          void Iner1_Init()//按键12，控制手势的开
  27          {
  28   1          EA = 1;
  29   1          EX1 = 1;
  30   1          IT1 = 0;
  31   1      }
  32          
  33          
  34          //定时器0初始化
  35          void Timer0_Init()
  36          {
  37   1          EA = 1;   
  38   1          TMOD |= 0x01; 
  39   1          TH0 = (65536 - 1000) / 256;
  40   1          TL0 = (65536 - 1000) % 256;  
  41   1          ET0 = 1;
  42   1          TR0 = 1; 
  43   1      }
  44          
  45          void main()
  46          { 
  47   1          unsigned char Tx[4] = {0xaa,0x55,0x04,0xff};//在发送端，发送的字节长度为4
  48   1          
  49   1          unsigned char keynum = 0xff;
  50   1      
  51   1          NRF24L01_Init();
  52   1          uart_init();
  53   1          Iner0_Init();
  54   1          Iner1_Init();
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:18:58 PAGE 2   

  55   1      
  56   1      
  57   1          //如果按下按键，则说明要设置为发送模式，发送数据
  58   1          //想要测试到STATUS = 0x2e，需要下载一遍，然后立马开串口，会出现2E,说明发送成功
  59   1          //按键的过程中，不需要后沿消抖，保证一定时间的正确值
  60   1          
  61   1          //一开始就是接收模式
  62   1          SetNRF_ReceiveDataMode();
  63   1          while(1)
  64   1          {
  65   2              /*注意！只有第二三四个字节的数据是可以用的！！！
  66   2              所以只索取后三个字节的数据，作为有效数据
  67   2              注意！因为还是没有解决重复接收最后一个数据的问题，
  68   2              所以，当后面截获到的数据都是第一个==第二个==第三个==第四个的，都是无效数据
  69   2              不做接收(近期重新测试，发现不再出现重复出现最后一个字节的问题，只是会多一个无效的字节，把四个字节的有
             -效数据变成了五个字节)
  70   2              */
  71   2             
  72   2              //扫描键盘
  73   2              keynum = Key_Scan();
  74   2              if(keynum == 1)
  75   2              {
  76   3                  Tx[2] = 0x01;
  77   3                  SetNRF_SendDataMode(Tx);
  78   3                  if(!CheckAck())//要是发送成功
  79   3                  {
  80   4                      //发送成功，那么就是开了
  81   4                  }
  82   3              }
  83   2              else if(keynum == 2)
  84   2              {
  85   3                  Tx[2] = 0x02;
  86   3                  SetNRF_SendDataMode(Tx);
  87   3                  if(!CheckAck())//要是发送成功
  88   3                  {
  89   4                       //发送成功，那么就是关了
  90   4                      
  91   4                  }
  92   3              }
  93   2              else if(keynum == 3)
  94   2              {
  95   3                  Tx[2] = 0x03;
  96   3                  SetNRF_SendDataMode(Tx);
  97   3                  if(!CheckAck())//要是发送成功
  98   3                  {
  99   4                  }
 100   3              }
 101   2              else if(keynum == 4)
 102   2              {
 103   3                  Tx[2] = 0x04;
 104   3                  SetNRF_SendDataMode(Tx);
 105   3                  if(!CheckAck())//要是发送成功
 106   3                  {
 107   4                  }
 108   3              }
 109   2              else if(keynum == 5)
 110   2              {
 111   3                  Tx[2] = 0x05;
 112   3                  SetNRF_SendDataMode(Tx);
 113   3                  if(!CheckAck())//要是发送成功
 114   3                  {
 115   4                      
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:18:58 PAGE 3   

 116   4                  }
 117   3              }
 118   2              else if(keynum == 6)
 119   2              {
 120   3                  Tx[2] = 0x06;
 121   3                  SetNRF_SendDataMode(Tx);
 122   3                  if(!CheckAck())//要是发送成功
 123   3                  {
 124   4                      
 125   4                  }
 126   3              }
 127   2              else if(keynum == 7)
 128   2              {
 129   3                  Tx[2] = 0x07;
 130   3                  SetNRF_SendDataMode(Tx);
 131   3                  if(!CheckAck())//要是发送成功
 132   3                  {
 133   4                      
 134   4                  }
 135   3              }
 136   2              else if(keynum == 8)
 137   2              {
 138   3                  Tx[2] = 0x08;
 139   3                  SetNRF_SendDataMode(Tx);
 140   3                  if(!CheckAck())//要是发送成功
 141   3                  {
 142   4                      
 143   4                  }
 144   3              }
 145   2              else if(keynum == 9)
 146   2              {
 147   3                  Tx[2] = 0x09;
 148   3                  SetNRF_SendDataMode(Tx);
 149   3                  if(!CheckAck())//要是发送成功
 150   3                  {
 151   4                      
 152   4                  }
 153   3                  
 154   3      //            //恢复到接收模式，
 155   3      //            SetNRF_ReceiveDataMode();
 156   3              }
 157   2              else 
 158   2              {}    
 159   2                
 160   2              //默认手势标志位为关闭的，要是开启了才有此功能
 161   2              if(Hand_Switch == YES)
 162   2              {         
 163   3                  getHandSignal();
 164   3                
 165   3                  //左移表示上一个    
 166   3                  if(Direction_flag == RIGHT)//
 167   3                  {
 168   4                      Direction_flag = NO;
 169   4                      Tx[2] = 0x0a;
 170   4                      SetNRF_SendDataMode(Tx);
 171   4                      if(!CheckAck())//要是发送成功
 172   4                      {
 173   5                          
 174   5                      } 
 175   4                  }
 176   3              }
 177   2              
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:18:58 PAGE 4   

 178   2          }
 179   1      }
 180          
 181          
 182          void Timer0_Isr() interrupt 1
 183          {
 184   1          static unsigned int i = 0;
 185   1        
 186   1          TH0 = (65536 - 1000) / 256;
 187   1          TL0 = (65536 - 1000) % 256;
 188   1        
 189   1          i ++;
 190   1          if(i == 500)
 191   1          {
 192   2              i = 0;
 193   2              One_s_Come = YES;
 194   2          }
 195   1      }
 196          
 197          void Int0_Isr() interrupt 0
 198          {
 199   1          EX0 = 0;
 200   1          Hand_Switch = NO;
 201   1          EX0 = 1;
 202   1      }
 203          
 204          void Int1_Isr() interrupt 2
 205          {
 206   1          EX1 = 0;
 207   1          Hand_Switch = YES;
 208   1          EX1 = 1;
 209   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    375    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
