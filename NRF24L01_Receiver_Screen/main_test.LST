C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN_TEST
OBJECT MODULE PLACED IN main_test.OBJ
COMPILER INVOKED BY: C:\Keil_MDK\C51\BIN\C51.EXE main_test.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\delay;.\uart;.\NRF2
                    -4L01__Receiver;.\LED16_64;.\WifiESP8266;.\PCF8563;.\DS18B20) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "AllFunc.h"
   2          
   3          /*点阵屏功能模块使用到的一些全局变量*/
   4          extern bit FifteenHundred_us_Come;//默认是没有到时间的，到了的话，会在while中判断然后清空
   5          extern bit One_s_Come;
   6          extern bit Four_hundred_ms_Come;//400ms到来的标志位，用来显示移位的
   7          extern unsigned char *OutPutStr[MAX_LEN];//用于输出显示的指针数组
   8          extern unsigned char row;//行，每次进入加一，上限十六行
   9          //在二维数组中第二维中的字节位置，也就是在一行广告屏中，要显示的哪八个字节
  10          extern unsigned char row_loc;
  11          extern unsigned int char_len;
  12          extern unsigned int temp_char_len;//显示函数中使用的字模偏移
  13          
  14          extern unsigned char DIS[];//行数据
  15          
  16          
  17          //bit OPEN_Flag = NO;//默认开关是关闭的，用按键九进行开启或者关闭，或者其他功能按钮开启
  18          
  19          
  20          /*wifi模块中使用的*/
  21          //接收到的数据和长度
  22          extern unsigned char  Get_str[40];
  23          extern unsigned char Get_str_loc;
  24          bit print_flag = NO;
  25          bit LastInfo_Flag = NO;//切换为上一个内容
  26          bit NextInfo_Flag = NO;//切换为下一个内容
  27          unsigned char ContentCount = 6;//用于计算显示第几个内容从0-6，一共7个内容，默认为关闭模式
  28          
  29          extern int wifi_str_len;//引用wifi模块函数中的字符长度变量
  30          
  31          /*模式选择*/
  32          
  33          unsigned char MODE_CHANGE = ROLL;//模式选择
  34          
  35          /*实时时钟使用到的变量*/
  36          extern unsigned char Time_Buf_ASCII[100];//这个里面会存储定时采集出来的时间
  37          bit Collect_Time_Flag_s = NO;//设置采集时钟信号的flag，定时采样，不能一直采样
  38          
  39          /*温度采集命令到来*/
  40          bit Collect_Tmp_Flag_4s = NO;//采集DS18B20命令
  41          bit COLLECT_TMP_FLAG = NO;//手机发送来的采集命令，要发送信息到手机上去了
  42          extern int real_tmp;
  43          int tempStorageTmp;//用来存储比较正常的温度值
  44          
  45          
  46          /*用于根据内容的编号，进行循环的显示，主要用在手机客户端的向上向下按钮上*/
  47          void showContentBy_ContentCount()
  48          {
  49   1          switch(ContentCount)
  50   1          {
  51   2            //显示时间，但是这里还没有做动态的填充内容
  52   2            case 0:{showAliveTimeInfo();break;}
  53   2            //显示温湿度
  54   2            case 1:{showAliveTmpInfo();break;}
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 2   

  55   2            //显示感谢信息
  56   2            case 2:{showStaitcInfo(ThankInfo,21);break;}
  57   2            //显示正在验收项目
  58   2            case 3:{showStaitcInfo(IntroductionInfo1,19);break;}
  59   2            //显示使用模块
  60   2            case 4:{showStaitcInfo(IntroductionInfo2,40);break;}
  61   2            //显示两种通信方法
  62   2            case 5:{showStaitcInfo(IntroductionInfo3,26);break;}
  63   2            //出错处理
  64   2            default:{ContentCount = 0;break;}
  65   2          }
  66   1      }
  67          
  68          
  69          /*专门为实时时间和温度采集做的检测，要实时检测，然后采集数据*/
  70          void specialForTimeTmp_Collecting()
  71          {
  72   1          /*专门为实时时钟设立*/
  73   1          if(ContentCount == 0)//如果Count==0，也就是说在显示时间，那么这时候我需要动态填充，一秒一次
  74   1          {
  75   2              /*实时时钟采集部分，这里单纯做一秒采集，不包含拼装和显示内容*/
  76   2              if(Collect_Time_Flag_s == YES)
  77   2              {
  78   3                  Collect_Time_Flag_s = NO;//清空标志位，开始采集
  79   3                  //采集时间，采集到的时间被拼装成固定的格式在Time_Buf_ASCII中，全部是ASCII码
  80   3                  P8563_gettime();
  81   3                  spellRTCTime();//拼装时间
  82   3              }
  83   2          }
  84   1          /*专门为温度设立*/
  85   1          else if(ContentCount == 1)
  86   1          {
  87   2              /*温湿度信号来临*/
  88   2              if(Collect_Tmp_Flag_4s == YES)
  89   2              {
  90   3                  Collect_Tmp_Flag_4s = NO;//清空标志位，开始采集
  91   3                  getTmp_and_Sprintf();
  92   3                  ModifyTmp();//调整采集到的值
  93   3                  spellTmpWithChinese();//拼装时间
  94   3              }
  95   2          }
  96   1      }
  97          
  98          
  99          
 100          
 101          /******************************************主函数*********************************************************
             -******/
 102          void main()
 103          {
 104   1          unsigned char RecData[5] = {0};//由于传输的数据宽度是5个字节，这里也使用五个字节作为一次数据
 105   1          unsigned char i = 0;
 106   1          
 107   1          /*用于拼装显示到手机上的信息*/
 108   1          unsigned char sendToClientBuf[50] = {0};
 109   1          
 110   1          int str_loc = 0;
 111   1          delay_s(2);
 112   1          uart_init();
 113   1          
 114   1          //采集一次温度
 115   1          getTmp_and_Sprintf();
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 3   

 116   1          if(real_tmp != 0)//首次采集就放入到保存的变量中
 117   1          {
 118   2              tempStorageTmp = real_tmp;
 119   2          }
 120   1          else
 121   1          {
 122   2              tempStorageTmp = 25;//要是失败了，那么先放入比较适宜的温度值，等待下一次更新
 123   2          }
 124   1          
 125   1          Init_Timer0();
 126   1          NRF24L01_Init();
 127   1          uart_init();
 128   1          delay_s(1);
 129   1          
 130   1          //要是要重新设置当前实时时钟，才要调用这个，然后在数组中填充日期的十六进制的BCD码，一般只要写一次就可以
 131   1          //P8563_init();   
 132   1          
 133   1          WifiESP8266_Init("Screen","0123456789","8080");
 134   1          
 135   1          ContentCount = 6;//默认开始为关闭模式
 136   1          //首先显示提示信息
 137   1           showStaitcInfo(InitInfo,4);
 138   1          
 139   1          //如果按下按键，则说明要设置为发送模式，发送数据
 140   1          //想要测试到STATUS = 0x2e，需要下载一遍，然后立马开串口，会出现2E,说明发送成功
 141   1          SetNRF_ReceiveDataMode();
 142   1          while(1)
 143   1          { 
 144   2              /*发送提示信息到手机，包括温度和采集错误的提示信息*/
 145   2              if(COLLECT_TMP_FLAG == YES)
 146   2              {
 147   3                  COLLECT_TMP_FLAG = NO;//清空操作
 148   3                  getTmp_and_Sprintf();//更新一次数据
 149   3                  ModifyTmp();
 150   3                  sprintf(sendToClientBuf,"Tmp:%03d",tempStorageTmp);
 151   3                  SendStrToClint(sendToClientBuf,0,strlen(sendToClientBuf));
 152   3                  memset(sendToClientBuf,0,sizeof(sendToClientBuf));//清空为下一次操作准备
 153   3              }         
 154   2            
 155   2            
 156   2            
 157   2              /*模式切换部分*/
 158   2              if(MODE_CHANGE == ROLL)
 159   2              {
 160   3                  specialForTimeTmp_Collecting();
 161   3                  showLeftRollString(OutPutStr,char_len);
 162   3              }
 163   2              else if(MODE_CHANGE == STATIC)
 164   2              {
 165   3                  specialForTimeTmp_Collecting();
 166   3                  showStaticString(OutPutStr,char_len);
 167   3              }
 168   2              
 169   2              /*通过wifi发来的命令辨析，切换内容*/
 170   2              if(NextInfo_Flag == YES)
 171   2              {
 172   3                  NextInfo_Flag = NO;
 173   3                  if(ContentCount >= 5)
 174   3                  {
 175   4                      ContentCount = 0;
 176   4                  }
 177   3                  else
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 4   

 178   3                  {
 179   4                      ContentCount ++;
 180   4                  }
 181   3                  //以上修改完成，就开始显示固定的内容
 182   3                  showContentBy_ContentCount();
 183   3              }
 184   2              else if(LastInfo_Flag == YES)
 185   2              {
 186   3                  LastInfo_Flag = NO;
 187   3                  if(ContentCount == 0)
 188   3                  {
 189   4                      ContentCount = 5;
 190   4                  }
 191   3                  else
 192   3                  {
 193   4                      ContentCount --;
 194   4                  }
 195   3                  showContentBy_ContentCount();
 196   3              }
 197   2            
 198   2      
 199   2              /*如果有了wifi发送信息过来，那么要进入做一些处理*/
 200   2                    /*用于打印收到的数据*/
 201   2              if(check_revStr() == OK)//也可以改成while在某个函数体中做
 202   2              {
 203   3                  /*************写对获取的字符串的操作**************/
 204   3                  //大于1的字符串，可以准备打印
 205   3                  if(wifi_str_len > 1)
 206   3                  {
 207   4                      //遍历字符串，如果包含命令符，不打印
 208   4                      for(str_loc = 0;str_loc < wifi_str_len; str_loc ++)
 209   4                      {
 210   5                          if((Get_str[str_loc] == '$') || (Get_str[str_loc] == '#')|| (Get_str[str_loc] == '^')
 211   5                            || (Get_str[str_loc] == '&')|| (Get_str[str_loc] == '*')|| (Get_str[str_loc] == '['))
 212   5                          {
 213   6                              print_flag = NO;
 214   6                          }
 215   5                      }
 216   4                      //如果能够打印，打印出来，不能打印要还原标志位能够打印的状态
 217   4                      if(print_flag == OK)
 218   4                      {
 219   5                          /*调用纯ASCII码接口，拼装字符串*/
 220   5                          /*点阵屏部分，注意要传入真实正确的字符个数，只能是ASCII码*/
 221   5                          transfer_String_to_OutPutStr(Get_str,Get_str_loc);
 222   5                          //这里做这一步，是为了让显示实时时间和温度的时候，不掩盖手机发送来的数据
 223   5                          ContentCount = 6;
 224   5                      }
 225   4                      else//还原默认的能够打印标志位
 226   4                      {
 227   5                          print_flag = OK;
 228   5                      }
 229   4      
 230   4                  }
 231   3                  clean_flag();//调用wifi模块中的清空函数
 232   3              }
 233   2        
 234   2      
 235   2              
 236   2              
 237   2              /*如果接收到了命令数据*/
 238   2              if(NRF_RecData(RecData))
 239   2              {
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 5   

 240   3                  //开始解析第第三个字节，该字节作为命令字
 241   3                  switch(RecData[2]) 
 242   3                  {
 243   4                    case 0x01:
 244   4                    {
 245   5                        ContentCount = 0;//内容计数标志，0表示这时候是显示时间模式 
 246   5                        showAliveTimeInfo();//显示时间，但是这里还没有做动态的填充内容
 247   5                      
 248   5                        uart_sendstr("Get cmd1");
 249   5                      
 250   5                        break;
 251   5                    }
 252   4                    case 0x02:
 253   4                    {
 254   5                        ContentCount = 1;//内容计数，1表示温湿度显示模式
 255   5                        showAliveTmpInfo();/*动态显示温湿度*/
 256   5                        break;
 257   5                    }
 258   4                    //显示感谢信息
 259   4                    case 0x03:
 260   4                    {ContentCount = 2;showStaitcInfo(ThankInfo,21);break;}
 261   4                    //显示正在验收项目
 262   4                    case 0x04:{ContentCount = 3;showStaitcInfo(IntroductionInfo1,19);break;}
 263   4                    //显示使用模块
 264   4                    case 0x05:{ContentCount = 4;showStaitcInfo(IntroductionInfo2,40);break;}
 265   4                    //显示两种通信方法
 266   4                    case 0x06:
 267   4                    {ContentCount = 5;showStaitcInfo(IntroductionInfo3,26);break;}
 268   4                    case 0x07:{MODE_CHANGE = ROLL;break;}
 269   4                    case 0x08:{MODE_CHANGE = STATIC;break;}
 270   4                    //显示初始化内容
 271   4                    case 0x09:{ContentCount = 6;showStaitcInfo(InitInfo,4);break;}
 272   4                    //向右手势命令，切换下一个内容
 273   4                    case 0x0a:{NextInfo_Flag = YES;break;}
 274   4                    //没有命令时的操作
 275   4                    default:{uart_sendstr("ERR");break;}
 276   4                  }
 277   3                
 278   3              }
 279   2            
 280   2              memset(RecData,0,4*sizeof(unsigned char));//每次接收完清空
 281   2          }
 282   1      }
 283          
 284          /*-----------------------------------------------
 285                       定时器执行动态扫描
 286          ------------------------------------------------*/
 287          void Timer0_isr(void) interrupt 1
 288          {
 289   1          static unsigned int counter_s  = 0;
 290   1          static unsigned int counter_us = 0;
 291   1          static unsigned int counter_ms = 0;
 292   1          
 293   1          static unsigned int counter_s_PCF8563 = 0;//专门为实时时钟定义一个计数变量
 294   1          static unsigned int counter_3s_Tmp = 0;
 295   1        
 296   1          TH0 = (65536 - TIMERVAL) / 256;
 297   1          TL0 = (65536 - TIMERVAL) % 256;  
 298   1        
 299   1          counter_s  ++;
 300   1          counter_us ++;
 301   1          counter_ms ++;
C51 COMPILER V9.53.0.0   MAIN_TEST                                                         07/29/2016 19:22:08 PAGE 6   

 302   1        
 303   1          counter_s_PCF8563 ++;
 304   1          counter_3s_Tmp ++;
 305   1        
 306   1          if(counter_us == US_COUNT_MAX)//进来一次就置为有效，但如果while中没有清空，就一直有效
 307   1          {
 308   2              FifteenHundred_us_Come = YES;
 309   2              counter_us = 0;//清空
 310   2          }
 311   1          if(counter_ms == MS_COUNT_MAX)//左移速度大约4-5ms移位一次
 312   1          {
 313   2              Four_hundred_ms_Come = YES;
 314   2              counter_ms = 0;
 315   2          }
 316   1          if(counter_s == S_COUNT_MAX)//大约1s切换静态内容显示
 317   1          {
 318   2              counter_s = 0;//清空
 319   2              One_s_Come = YES;//标志位有效
 320   2          }
 321   1          
 322   1          
 323   1          if(counter_s_PCF8563 == S_COUNT_MAX_PCF8563)
 324   1          {
 325   2              counter_s_PCF8563 = 0;//清空计数
 326   2              Collect_Time_Flag_s = YES;
 327   2          }
 328   1          
 329   1          if(counter_3s_Tmp == S_COUNT_MAX_TMP)
 330   1          {
 331   2              counter_3s_Tmp = 0;
 332   2              Collect_Tmp_Flag_4s = YES;
 333   2          }
 334   1      
 335   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1126    ----
   CONSTANT SIZE    =    100    ----
   XDATA SIZE       =     14      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
