C51 COMPILER V9.53.0.0   TMP_HUM                                                           05/26/2016 12:29:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE TMP_HUM
OBJECT MODULE PLACED IN tmp_hum.obj
COMPILER INVOKED BY: C:\Keil_MDK\C51\BIN\C51.EXE HumTmpBest\tmp_hum.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\delay;.\ua
                    -rt;.\NRF24L01__Receiver;.\LED16_64;.\WifiESP8266;.\PCF8563;.\HumTmpBest) DEBUG OBJECTEXTEND PRINT(.\tmp_hum.lst) TABS(2)
                    - OBJECT(tmp_hum.obj)

line level    source

   1          #include "AllFunc.h"
   2          
   3          //#include <reg52.h>
   4          //#include <intrins.h>
   5          //#include "delay.h"
   6          //#include "uart.h"
   7          
   8          
   9          ///*温湿度中使用到的存储全局的变量*/
  10          ////hum_val = (hum_tmp[0] / 10)*10 + (hum_tmp[0] % 10);
  11          ////tmp_val = (hum_tmp[2] / 10)*10 + (hum_tmp[2] % 10);
  12          //int hum_val = 0;
  13          //int tmp_val = 0;
  14          ///*
  15          //hum_tmp[0]中装的是湿度
  16          //hum_tmp[2]中装的是温度
  17          //都是十六进制
  18          //*/
  19          //unsigned char hum_tmp[5] = {0};
  20          //unsigned char hum_tmp_buf[20] = {0};//组装温湿度成一个字符串
  21          
  22          //#define OK 1
  23          //#define ERROR 0
  24          ////请根据自己的dht11 接的IO 口来改动位定义
  25          //sbit dht11 = P2^0;
  26          ////防止在与硬件通信时发生死循环的计数范围
  27          //#define NUMBER 20
  28          //#define SIZE 5
  29          //static unsigned char status;
  30          
  31          ////存放五字节数据的数组
  32          //unsigned char value_array[SIZE];
  33          
  34          ///*可在其他的文件引用温湿度值,实际是温度的整数的10 倍
  35          //如dht11 读回的温度是26,则temp_value = 260, 湿度同理*/
  36          //int temp_value, humi_value;
  37          //unsigned char ReadValue(void);
  38          //void Delay_1ms(unsigned int ms)
  39          //{
  40          //    unsigned int x, y;
  41          //    for(x = ms; x > 0; x--)
  42          //    {
  43          //        for(y = 124; y > 0; y--);
  44          //    }
  45          //}
  46          
  47          
  48          
  49          
  50          ///*将温湿度读取出来，并且拼装成一个字符串*/
  51          //void getTmpHum_and_sprintf()
  52          //{
  53          //    /*温湿度模块*/
C51 COMPILER V9.53.0.0   TMP_HUM                                                           05/26/2016 12:29:24 PAGE 2   

  54          //    if(ReadTempAndHumi() == OK)
  55          //    {
  56          //        //如果成功，就转化成十进制
  57          //        hum_val = (value_array[0] / 10)*10 + (value_array[0] % 10);
  58          //        tmp_val = (value_array[2] / 10)*10 + (value_array[2] % 10);  
  59          //        sprintf(hum_tmp_buf,"Tmp:%02d Hum:%02d",tmp_val,tmp_val);
  60          //    }
  61          //    else
  62          //    {
  63          //        sprintf(hum_tmp_buf,"Tmp:FF Hum:FF");
  64          //    }
  65          //}
  66          
  67          
  68          
  69          
  70          
  71          
  72          //void Delay_10us(void)
  73          //{
  74          //    unsigned char i;
  75          //    i--;
  76          //    i--;
  77          //    i--;
  78          //    i--;
  79          //    i--;
  80          //    i--;
  81          //}
  82          
  83          ///*读一个字节的数据*/
  84          //unsigned char ReadValue(void)
  85          //{
  86          //    unsigned char count, value = 0, i;
  87          //    status = OK; //设定标志为正常状态
  88          //    for(i = 8; i > 0; i--)
  89          //    {
  90          //        //高位在先
  91          //        value <<= 1;
  92          //        count = 0;
  93          //        //每一位数据前会有一个50us 的低电平时间.等待50us 低电平结束
  94          //        while(dht11 == 0 && count++ < NUMBER);
  95          //        if(count >= NUMBER)
  96          //        {
  97          //            status = ERROR; //设定错误标志
  98          //            return 0; //函数执行过程发生错误就退出函数
  99          //        }
 100          //        //26-28us 的高电平表示该位是0,为70us 高电平表该位1
 101          //        Delay_10us();
 102          //        Delay_10us();
 103          //        Delay_10us();
 104          //        //延时30us 后检测数据线是否还是高电平
 105          //        if(dht11 != 0)
 106          //        {
 107          //            //进入这里表示该位是1
 108          //            value++;
 109          //            //等待剩余(约40us)的高电平结束
 110          //            while(dht11 != 0 && count++ < NUMBER)
 111          //            {
 112          //                dht11 = 1;
 113          //            }
 114          //            if(count >= NUMBER)
 115          //            {
C51 COMPILER V9.53.0.0   TMP_HUM                                                           05/26/2016 12:29:24 PAGE 3   

 116          //                status = ERROR; //设定错误标志
 117          //                return 0;
 118          //            }
 119          //        }
 120          //    }
 121          //    return (value);
 122          //}
 123          ////读一次的数据,共五字节
 124          //unsigned char ReadTempAndHumi(void)
 125          //{
 126          //    unsigned char i = 0, check_value = 0,count = 0;
 127          //    EA = 0;
 128          //    dht11 = 0; //拉低数据线大于18ms 发送开始信号
 129          //    Delay_1ms(20); //需大于18 毫秒
 130          //    dht11 = 1; //释放数据线,用于检测低电平的应答信号
 131          //    //延时20-40us,等待一段时间后检测应答信号,应答信号是从机拉低数据线80us
 132          //    Delay_10us();
 133          //    Delay_10us();
 134          //    Delay_10us();
 135          //    Delay_10us();
 136          //    if(dht11 != 0) //检测应答信号,应答信号是低电平
 137          //    {
 138          //        //没应答信号
 139          //        EA = 1;
 140          //        return ERROR;
 141          //    }
 142          //    else
 143          //    {
 144          //        //有应答信号
 145          //        while(dht11 == 0 && count++ < NUMBER); //等待应答信号结束
 146          //        if(count >= NUMBER) //检测计数器是否超过了设定的范围
 147          //        {
 148          //            dht11 = 1;
 149          //            EA = 1;
 150          //            return ERROR; //读数据出错,退出函数
 151          //        }
 152          //        count = 0;
 153          //        dht11 = 1;//释放数据线
 154          //        //应答信号后会有一个80us 的高电平，等待高电平结束
 155          //        while(dht11 != 0 && count++ < NUMBER);
 156          //        if(count >= NUMBER)
 157          //        {
 158          //            dht11 = 1;
 159          //            EA = 1;
 160          //            return ERROR; //退出函数
 161          //        }
 162          //        //读出湿.温度值
 163          //        for(i = 0; i < SIZE; i++)
 164          //        {
 165          //            value_array[i] = ReadValue();
 166          //            if(status == ERROR)//调用ReadValue()读数据出错会设定status 为ERROR
 167          //            {
 168          //                dht11 = 1;
 169          //                EA = 1;
 170          //                return ERROR;
 171          //            }
 172          //            //读出的最后一个值是校验值不需加上去
 173          //            if(i != SIZE - 1)
 174          //            {
 175          //                //读出的五字节数据中的前四字节数据和等于第五字节数据表示成功
 176          //                check_value += value_array[i];
 177          //            }
C51 COMPILER V9.53.0.0   TMP_HUM                                                           05/26/2016 12:29:24 PAGE 4   

 178          //        } //end for
 179          //        //在没用发生函数调用失败时进行校验
 180          //        if(check_value == value_array[SIZE - 1])
 181          //        {
 182          //            //将温湿度扩大10 倍方便分离出每一位
 183          //            humi_value = value_array[0] * 10;
 184          //            temp_value = value_array[2] * 10;
 185          //            dht11 = 1;
 186          //            EA = 1;
 187          //            return OK; //正确的读出dht11 输出的数据
 188          //        }
 189          //        else
 190          //        {
 191          //            //校验数据出错
 192          //            EA = 1;
 193          //            return ERROR;
 194          //        }
 195          //    }
 196          //}
 197          
 198          
 199          //void main()
 200          //{
 201          //    unsigned char i;
 202          //    uart_init();
 203          //    delay_s(1);//等待1秒，跳过模块初始的不稳定
 204          //    while(1)
 205          //    {
 206          //        delay_s(3);
 207          //      
 208          //        if(ReadTempAndHumi() == OK)
 209          //        {
 210          //            for(i = 0;i < 5;i ++)
 211          //            {
 212          //                uart_sendbyte(value_array[i]);//打印到串口上显示
 213          //            }
 214          //        }
 215          //          
 216          //        for(i = 0;i < 5;i ++)
 217          //        {
 218          //           value_array[i] = 0x00;
 219          //        }  
 220          //    }  
 221          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
