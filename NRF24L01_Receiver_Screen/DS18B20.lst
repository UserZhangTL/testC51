C51 COMPILER V9.53.0.0   DS18B20                                                           07/29/2016 19:21:39 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN DS18B20.obj
COMPILER INVOKED BY: C:\Keil_MDK\C51\BIN\C51.EXE DS18B20\DS18B20.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\delay;.\uart;
                    -.\NRF24L01__Receiver;.\LED16_64;.\WifiESP8266;.\PCF8563;.\DS18B20) DEBUG OBJECTEXTEND PRINT(.\DS18B20.lst) TABS(2) OBJEC
                    -T(DS18B20.obj)

line level    source

   1          #include "AllFunc.h"
   2          
   3          
   4          //一位的数据位
   5          sbit ds = P2^0;
   6          bit ack;
   7          int real_tmp;
   8          unsigned char tmpInfo_buf[8] = {0};
   9          
  10          //复位初始化
  11          void ds_reset()
  12          {
  13   1          //根据手册
  14   1          ds = 1;
  15   1          ds = 0;  
  16   1          delay_us(200);
  17   1          delay_us(200);
  18   1          ds = 1;  //置一
  19   1          delay_us(30);
  20   1          if(ds == 0)  //如果有相应，ack置一
  21   1          {
  22   2              ack = 1;
  23   2          }
  24   1          else
  25   1          {
  26   2              ack = 0;
  27   2          }
  28   1          delay_us(200);
  29   1          delay_us(200);//延时一下，以防后面数据操作在应答状态下作操作，出现错误
  30   1      }
  31          
  32          
  33          //写入一个字节数据
  34          void ds_writebyte(unsigned char byte)
  35          {
  36   1          unsigned char i = 0;
  37   1          for(i = 0;i < 8;i ++)
  38   1          {
  39   2              ds = 1;
  40   2              ds = 0;
  41   2              _nop_();
  42   2              _nop_();
  43   2              ds = byte & 0x01;
  44   2              delay_us(40);
  45   2              byte >>= 1;
  46   2          }
  47   1          //最后需要拉高
  48   1          ds = 1;
  49   1      }
  50          
  51          bit ds_readbit()
  52          {
  53   1          bit temp;
C51 COMPILER V9.53.0.0   DS18B20                                                           07/29/2016 19:21:39 PAGE 2   

  54   1          ds = 1;
  55   1          ds = 0;
  56   1          _nop_();
  57   1          _nop_();
  58   1          ds = 1;//先把ds拉高，要是为低电平，会被拉低
  59   1          temp = ds;//赋值返回
  60   1          delay_us(40);
  61   1        
  62   1          return temp;
  63   1      }
  64          
  65          
  66          //读出
  67          unsigned char ds_readbyte()
  68          {
  69   1         
  70   1          unsigned char j,k;
  71   1          unsigned char i = 0;
  72   1          
  73   1          for(i = 0;i < 8;i ++)
  74   1          {
  75   2              j = ds_readbit();
  76   2              k = (j << 7) | (k >> 1);
  77   2          }
  78   1          
  79   1          
  80   1          return k;
  81   1      }
  82          
  83          extern int tempStorageTmp;
  84          /*采集温湿度，然后sprintf拼装完成*/
  85          void getTmp_and_Sprintf()
  86          {
  87   1          unsigned char a;
  88   1          unsigned int tmp,b;
  89   1          int temp_tmp = 0;//临时存储的温度
  90   1          
  91   1          ds_reset();
  92   1          ds_writebyte(0xcc);
  93   1          ds_writebyte(0x44);
  94   1          delay_ms(50);
  95   1          ds_reset();
  96   1          ds_writebyte(0xcc);
  97   1          ds_writebyte(0xbe);
  98   1              
  99   1          a = ds_readbyte();
 100   1          b = ds_readbyte();
 101   1          tmp = (b << 8) + a;
 102   1        
 103   1      
 104   1          real_tmp = (int)tmp * 0.0625;
 105   1          ModifyTmp();//调整一次
 106   1          /*正负数都可以拼接，多留出一位用来放零下温度*/
 107   1          sprintf(tmpInfo_buf,"%03d",tempStorageTmp);
 108   1          
 109   1      }
 110          
 111          /*用于避免温度的显示错误*/
 112          void ModifyTmp()
 113          {
 114   1          if(real_tmp != 0)
 115   1          {
C51 COMPILER V9.53.0.0   DS18B20                                                           07/29/2016 19:21:39 PAGE 3   

 116   2             tempStorageTmp = real_tmp; 
 117   2          }
 118   1      }
 119          
 120          //void main()
 121          //{
 122          //    while(1)
 123          //    {
 124          //      show_tmp();
 125          //    }
 126          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    301    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     10       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
